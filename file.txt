diff --git a/Cargo.lock b/Cargo.lock
index a667f17..1adf8aa 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -56,10 +56,11 @@ checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"
 
 [[package]]
 name = "flipper-rpc"
-version = "0.1.2"
+version = "0.2.0"
 dependencies = [
  "log",
  "memchr",
+ "paste",
  "prost",
  "serialport",
  "thiserror",
@@ -122,6 +123,12 @@ dependencies = [
  "libc",
 ]
 
+[[package]]
+name = "paste"
+version = "1.0.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "57c0d7b74b563b49d38dae00a0c37d4d6de9b432382b2892f0574ddcae73fd0a"
+
 [[package]]
 name = "proc-macro2"
 version = "1.0.95"
diff --git a/Cargo.toml b/Cargo.toml
index fbec4b6..24c9470 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -1,9 +1,10 @@
 [package]
 name = "flipper-rpc"
-version = "0.1.2"
+version = "0.2.0"
 edition = "2024"
 description = "Flipper Zero Remote Procedure Call Library (RPC) – A Rust 🦀 library enabling apps to remotely control a Flipper Zero device, similar to qFlipper. Built using the official Flipper Zero protobuf definitions."
 repository = "https://github.com/elijah629/flipper-rpc"
+documentation = "https://docs.rs/flipper-rpc"
 keywords = ["flipperzero", "rpc", "qflipper", "control", "flipper"]
 categories = ["encoding", "api-bindings", "development-tools"]
 readme = "README.md"
@@ -12,10 +13,15 @@ license = "MIT"
 [dependencies]
 log = "0.4.27"
 memchr = "2.7.4"
+paste = "1.0.15"
 prost = "0.13.5"
 serialport = { version = "4.7.2", default-features = false }
 thiserror = "2.0.12"
 
+[features]
+default = ["optimized-proto-reading"]
+optimized-proto-reading = []
+
 [lib]
 path = "src/lib.rs"
 
diff --git a/README.md b/README.md
index 6a8aba6..873efed 100644
--- a/README.md
+++ b/README.md
@@ -48,23 +48,14 @@ flipper-rpc = "0.1.0"  # Replace with the latest version from crates.io
 ## 🚀 Usage
 
 ```rust
-let mut cli = Cli::new("/dev/ttyACM0".to_string());
-// or use Cli::flipper_ports() to find the port dynamically
-
-let ping = proto::Main {
-    command_id: 0,
-    command_status: proto::CommandStatus::Ok.into(),
-    has_next: false,
-    content: Some(proto::main::Content::SystemPingRequest(
-        proto::system::PingRequest {
-            data: vec![0xDE, 0xAD, 0xBE, 0xEF],
-        },
-    )),
-};
-
-let response = cli.send_read_rpc_proto(ping)?;
-
-println!("{response:?}");
+let ports = list_flipper_ports()?;
+let port = &ports[0].port_name;
+
+let mut cli = SerialRpcTransport::new(port.to_string())?;
+
+let response = cli.send_and_receive(RpcRequest::SystemPlayAudiovisualAlert)?;
+
+assert!(response.is_none());
 ```
 
 ---
@@ -82,20 +73,16 @@ _nothing_), I decided to write my own. Enjoy!
    uses [`serialport`](https://docs.rs/serialport), which is simple and only
    requires the port path and a baud rate.
 
-2. **Baud rate? Doesn’t matter.** Serial over USB (`CDC-ACM`) abstracts this
-   away. It’ll work at basically any speed.
+2. **Baud rate... Apparently doesn't matter** Serial over USB (`CDC-ACM`)
+   abstracts baud rate away, it must be reasonable and capable by the hardware
+   and software.
 
 3. **Drain the buffer.** Keep reading until you see the shell prompt string
-   `>:`. This clears old buffer content, since reads begin from the buffer start
-   — not your last write.
-
-4. **Enter RPC mode.** Send:
-
-   ```txt
-   start_rpc_session\r
-   ```
+   `">: "`. This clears old buffer content, since reads begin from the buffer
+   start — not your last write.
 
-   > **Note:** `\r\n` does **not** work here.
+4. **Enter RPC mode.** Write the string: `start_rpc_session\r`
+   > **Note:** `\r\n` does **not** work here. I do not know why.
 
 5. **Drain again.** Read until you receive `\n`, which indicates that the
    Flipper has accepted the command.
diff --git a/src/bin.rs b/src/bin.rs
index 1c55edc..b2f2205 100644
--- a/src/bin.rs
+++ b/src/bin.rs
@@ -1,27 +1,23 @@
+use std::io;
+
 use flipper_rpc::{
-    cli::{self, Cli},
-    proto,
+    rpc::RpcRequest,
+    transport::{
+        Transport,
+        serial::{list_flipper_ports, rpc::SerialRpcTransport},
+    },
 };
 
-fn main() {
-    let ports = Cli::flipper_ports().unwrap();
+fn main() -> std::io::Result<()> {
+    let ports = list_flipper_ports()?;
 
-    let port = &ports[0].0;
+    let port = &ports[0].port_name;
 
-    let mut cli = Cli::new(port.to_string()).unwrap();
+    let mut cli = SerialRpcTransport::new(port.to_string())?;
 
-    let ping = proto::Main {
-        command_id: 0,
-        command_status: proto::CommandStatus::Ok.into(),
-        has_next: false,
-        content: Some(proto::main::Content::SystemPingRequest(
-            proto::system::PingRequest {
-                data: vec![0xDE, 0xAD, 0xBE, 0xEF],
-            },
-        )),
-    };
+    let response = cli.send_and_receive(RpcRequest::SystemPlayAudiovisualAlert)?;
 
-    let response = cli.send_read_rpc_proto(ping).unwrap();
+    assert!(response.is_none());
 
-    println!("{response:?}");
+    Ok(())
 }
diff --git a/src/cli.rs b/src/cli.rs
deleted file mode 100644
index 0e57862..0000000
--- a/src/cli.rs
+++ /dev/null
@@ -1,383 +0,0 @@
-//! # Flipper CLI
-//!
-//! A client for communicating with Flipper Zero devices over a serial port using Protobuf RPC.
-//!
-//! This crate provides a `Cli` struct which manages an RPC session, sending and receiving messages
-//! defined in the `proto` module.
-//!
-//! ## Examples
-//!
-//! ```no_run
-//! use flipper_cli::Cli;
-//! use flipper_cli::error::Result;
-//!
-//! # fn main() -> Result<()> {
-//! // List available Flipper devices
-//! if let Some(ports) = Cli::flipper_ports() {
-//!     for (port_name, product) in ports {
-//!         println!("Found {} on {}", product, port_name);
-//!     }
-//! }
-//!
-//! let port = &ports[0].0;
-//! let mut cli = Cli::new(port.to_string())?;
-//!
-//! // Send a ping RPC message
-//! let ping =  let ping = proto::Main {
-//!     command_id: 0,
-//!     command_status: proto::CommandStatus::Ok.into(),
-//!     has_next: false,
-//!     content: Some(proto::main::Content::SystemPingRequest(
-//!         proto::system::PingRequest {
-//!             data: vec![0xDE, 0xAD, 0xBE, 0xEF],
-//!         },
-//!     )),
-//! };
-//!
-//! let response = cli.send_read_rpc_proto(ping)?;
-//! println!("Received: {:?}", response);
-//! # Ok(())
-//! # }
-//! ```
-
-#![deny(missing_docs)]
-
-use log::{debug, trace};
-use prost::{Message, bytes::Buf};
-use serialport::SerialPort;
-use std::time::Duration;
-
-use crate::{error::Result, proto, reader_utils::drain_until};
-
-const FLIPPER_BAUD: u32 = 115_200;
-
-/// Flipper RPC communication class
-#[derive(Debug)]
-pub struct Cli {
-    command_id: u32,
-    port: Box<dyn SerialPort>,
-}
-
-impl Cli {
-    /// Lists all connected Flipper devices by USB serial port and product name.
-    ///
-    /// # Returns
-    ///
-    /// - `Some(Vec<(port_name, product_name)>)` if querying ports succeeds.
-    /// - `None` if listing ports fails, or no ports are available.
-    ///
-    /// # Examples
-    ///
-    /// ```no_run
-    /// if let Some(devices) = Cli::flipper_ports() {
-    ///     for (port, name) in devices {
-    ///         println!("{}: {}", port, name);
-    ///     }
-    /// }
-    /// ```
-    pub fn flipper_ports() -> Option<Vec<(String, String)>> {
-        debug!("Scanning for ports");
-        serialport::available_ports().ok().map(|ports| {
-            ports
-                .into_iter()
-                .filter_map(|port| {
-                    debug!("Found port: {:?}", port);
-                    if let serialport::SerialPortType::UsbPort(usb_info) = port.port_type {
-                        if usb_info.manufacturer.as_deref() == Some("Flipper Devices Inc.") {
-                            if let Some(product) = usb_info.product {
-                                debug!("-- Port is a flipper");
-                                return Some((port.port_name, product));
-                            }
-                        }
-                    }
-                    debug!("-- Port is not a flipper");
-                    None
-                })
-                .collect()
-        })
-    }
-
-    /// Opens a new CLI session on the given serial port path.
-    ///
-    /// Initialize the serial connection and start an RPC session.
-    ///
-    /// # Errors
-    ///
-    /// Returns an error if the port cannot be opened, initialization commands fail, or
-    /// the RPC banner prompt is not received.
-    ///
-    /// # Examples
-    ///
-    /// ```no_run
-    /// let mut cli = Cli::new("/dev/ttyACM0".to_string())?;
-    /// ```
-    pub fn new(port: String) -> Result<Self> {
-        let mut port = serialport::new(port, FLIPPER_BAUD)
-            .timeout(Duration::from_secs(2))
-            .open()?;
-
-        debug!("Draining port until prompt");
-        drain_until(&mut port, ">: ", Duration::from_secs(2))?;
-
-        debug!("Calling start_rpc_session");
-        port.write_all("start_rpc_session\r".as_bytes())?;
-        port.flush()?;
-
-        debug!("Draining until start_rpc_session has a \\n");
-        drain_until(&mut port, "\n", Duration::from_secs(2))?;
-
-        Ok(Self {
-            port,
-            command_id: 0,
-        })
-    }
-
-    /// Sends a length-delimited Protobuf RPC message to the Flipper.
-    ///
-    /// The internal command counter is used to set `command_id` on the message, whatever value is
-    /// set in `rpc` will be overwritten
-    ///
-    /// # Errors
-    ///
-    /// Returns an error if the message cannot be encoded or written to the port.
-    ///
-    /// # Examples
-    ///
-    /// ```no_run
-    /// let ping = proto::Main {
-    /// command_id: 0,
-    ///     command_status: proto::CommandStatus::Ok.into(),
-    ///     has_next: false,
-    ///     content: Some(proto::main::Content::SystemPingRequest(
-    ///         proto::system::PingRequest {
-    ///             data: vec![0xDE, 0xAD, 0xBE, 0xEF],
-    ///         },
-    ///     )),
-    /// };
-    /// cli.send_rpc_proto(ping)?;
-    /// ```
-    pub fn send_rpc_proto(&mut self, mut rpc: proto::Main) -> Result<()> {
-        trace!("send_rpc_proto");
-        rpc.command_id = self.command_id;
-
-        debug!("Encoding RPC");
-        let encoded = rpc.encode_length_delimited_to_vec();
-        debug!("Writing RPC");
-        self.port.write_all(&encoded)?;
-
-        self.command_id = self.command_id.wrapping_add(1);
-
-        Ok(())
-    }
-
-    /// Reads the next RPC message from the Flipper using a two-stage buffered read.
-    ///
-    /// Uses a two-shot method of reading: first to get varint length + partial data, then to
-    /// fetch remaining bytes if the message exceeds the initial buffer.
-    ///
-    /// # Errors
-    ///
-    /// Returns an error if no data is received, decoding fails, or IO operations fail.
-    ///
-    /// # Examples
-    ///
-    /// ```no_run
-    /// let response = cli.read_rpc_proto()?;
-    /// ```
-    pub fn read_rpc_proto(&mut self) -> Result<proto::Main> {
-        trace!("read_rpc_proto");
-        // INFO: Super-overcomplicated but fast and efficent way of reading any length varint + data in exactly two
-        // syscalls
-        // Tries to use a stack-based approach when possible and does it efficently
-
-        // Hard limit for all stack-based buffers
-        // NOTE: Adding 10 as Varint max length is 10
-        const STACK_LIMIT: usize = 10 + 128;
-
-        let mut buf = [0u8; STACK_LIMIT];
-
-        // Yeah that first comment was somewhat of a lie, it should be a MINIMUM of two reads.
-        // If the first read fails, we wouldn't know and it would return incomplete data.
-        // So we have to have a fail-safe loop. This actually does not cost much, as it will
-        // still read only once if it doesn't fail
-
-        // Error-prone code
-        // ```rs
-        // let read = self.port.read(&mut buf)?;
-        // ```
-        //
-        // Error-proof code!
-
-        let mut read = 0;
-        let mut available_bytes = buf.len();
-
-        debug!("Reading varint");
-        while read < available_bytes {
-            match self.port.read(&mut buf[read..available_bytes]) {
-                Ok(0) => break, // No more data
-                Ok(n) => {
-                    available_bytes = self.port.bytes_to_read()? as usize;
-                    read += n
-                }
-                Err(ref e) if e.kind() == std::io::ErrorKind::TimedOut => break,
-                Err(e) => return Err(e.into()),
-            }
-        }
-
-        if read == 0 {
-            return Err(std::io::Error::new(
-                std::io::ErrorKind::UnexpectedEof,
-                "no data read, failed to parse varint",
-            )
-            .into());
-        }
-
-        debug!("Decoding data length");
-        let total_data_length = prost::decode_length_delimiter(&buf[..read])?;
-
-        // We have the length of the data, however some or all of the actual data is inside of buf,
-        // after the varint, it just continues to RPC data.
-
-        // How many bytes does the varint take up?
-        debug!("Calculating varint length");
-        let varint_length = varint_length(total_data_length);
-
-        // PERF: All the data that is not varint data, this is another main optimization,
-        // we skip another read, as we have already read the data.
-        // We get all data after the varint until we stopped reading
-        let partial_data = &buf[varint_length..read];
-
-        // NOTE: We can skip the math since varint_length is always `1` for numbers 0-9 (varints go
-        // above 1 byte when value > 127, since they only use 7 bits, and the MSB is an indicator
-        // of weather the varint is done). If we read
-        // more data, we would have to do:
-        // total_data_length <= 10 - varint_length or total_data_length <= partial_data.len()
-        let read_all_data = total_data_length <= partial_data.len();
-
-        // PERF: If all of the data was read, the entire message is contained within the 10 byte buffer,
-        // so we do not need to perfom another read operation
-        let main = if read_all_data {
-            // INFO: partial_data is all of the data in the buffer besides the varint and
-            // trailing zeros if we read less than the buf's size
-
-            debug!("FASTEST: Decoding response");
-            proto::Main::decode(partial_data)?
-        } else {
-            // WARN: Data did NOT fit inside of the buffer, this means that some of the data is
-            // missing from the buffer
-
-            // `partial_data` is the only data that was in the buffer
-
-            // Now we need to get the remaining bytes and join them together with partial_data to
-            // get the full data, then we should decode it
-
-            // PERF: Optimization alert! As no one expected, stack buffers are waaay faster than vecs.
-            // Capiitalizing on this, all messages with < STACK_LIMIT bytes will be put (partially)
-            // into a stack buffer. Then, we can chain them with bytes::buf::Buf and pass that
-            // directly to the decoder for a zero-overhead decoding
-            //
-            // PERF: For messages larger than STACK_LIMIT, we do a vec based processing. Since stack
-            // sizes must be known at compile time, this is the only way to do a stack-processing
-            // method with data that could be infinitely large.
-
-            // How much data is left
-            let remaining_length = total_data_length - partial_data.len();
-
-            if remaining_length <= STACK_LIMIT {
-                debug!("FAST: Decoding response");
-                // Free speed for small messages!
-                let mut stack_buf = [0u8; STACK_LIMIT];
-                self.port.read_exact(&mut stack_buf[..remaining_length])?;
-
-                let chained = partial_data.chain(&stack_buf[..remaining_length]);
-
-                proto::Main::decode(chained)?
-            } else {
-                debug!("SLOW: Decoding response");
-                // Uses a slower heap (vec) based decoding for larger messages.
-                let mut remaining_data = vec![0u8; remaining_length];
-                self.port.read_exact(&mut remaining_data)?;
-
-                let data = [partial_data.to_vec(), remaining_data].concat();
-
-                proto::Main::decode(data.as_slice())?
-            }
-        };
-
-        Ok(main)
-    }
-
-    /// Reads the next RPC message from the Flipper using a byte-wise varint decoder.
-    ///
-    /// This method issues up to 11 syscalls but and relies on only heap buffers.
-    /// Opt to use read_rpc_proto when possible
-    ///
-    /// # Errors
-    ///
-    /// Returns an error if IO operations fail or decoding fails.
-    ///
-    /// # Examples
-    ///
-    /// ```no_run
-    /// let response = cli.read_rpc_proto_bytewise()?;
-    /// ```
-    pub fn read_rpc_proto_bytewise(&mut self) -> Result<proto::Main> {
-        // NOTE: Comapred to the one above, this looks stupid and shitty. It makes a maximum of 11
-        // syscalls, with a minimum of 2. 11 for large messages and 2 for messages < 127 bytes.
-        // It also only relies on the heap
-
-        let mut buf = Vec::with_capacity(10);
-        let mut byte = [0u8; 1];
-
-        loop {
-            self.port.read_exact(&mut byte)?;
-            buf.push(byte[0]);
-            if byte[0] & 0x80 == 0 {
-                break;
-            }
-        }
-
-        let len = prost::decode_length_delimiter(buf.as_slice())?;
-        let mut msg_buf = vec![0u8; len];
-        self.port.read_exact(&mut msg_buf)?;
-
-        let main = proto::Main::decode(msg_buf.as_slice())?;
-
-        Ok(main)
-    }
-
-    /// Sends an RPC request and immediately reads the response.
-    ///
-    /// # Errors
-    ///
-    /// Propagates errors from `send_rpc_proto` or `read_rpc_proto`.
-    ///
-    /// # Examples
-    ///
-    /// ```no_run
-    /// let response = cli.send_read_rpc_proto(request)?;
-    /// ```
-    pub fn send_read_rpc_proto(&mut self, rpc: proto::Main) -> Result<proto::Main> {
-        self.send_rpc_proto(rpc)?;
-        self.read_rpc_proto()
-    }
-}
-
-/// Returns the number of bytes used by the varint encoding of `value`.
-///
-/// This does not allocate or write the varint, only computes its length.
-///
-/// # Examples
-///
-/// ```
-/// let len = varint_length(300);
-/// assert_eq!(len, 2);
-/// ```
-fn varint_length(mut value: usize) -> usize {
-    let mut len = 1;
-    while value >= 0x80 {
-        value >>= 7;
-        len += 1;
-    }
-    len
-}
diff --git a/src/error.rs b/src/error.rs
deleted file mode 100644
index d3d0635..0000000
--- a/src/error.rs
+++ /dev/null
@@ -1,17 +0,0 @@
-use std::io;
-
-use thiserror::Error;
-
-#[derive(Debug, Error)]
-pub enum Error {
-    #[error(transparent)]
-    SerialPort(#[from] serialport::Error),
-
-    #[error(transparent)]
-    Io(#[from] io::Error),
-
-    #[error(transparent)]
-    DecodeError(#[from] prost::DecodeError),
-}
-
-pub type Result<T> = std::result::Result<T, Error>;
diff --git a/src/lib.rs b/src/lib.rs
index 91ec210..b094827 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -2,24 +2,24 @@
 //! from a Flipper Zero over a serial connection.
 //! ## Usage
 //! ```rust
-//! let mut cli = Cli::new("/dev/ttyACM0".to_string());
-//! // or use Cli::flipper_ports() to find the port dynamically
-//!  let ping = proto::Main {
-//!     command_id: 0,
-//!     command_status: proto::CommandStatus::Ok.into(),
-//!     has_next: false,
-//!     content: Some(proto::main::Content::SystemPingRequest(
-//!         proto::system::PingRequest {
-//!             data: vec![0xDE, 0xAD, 0xBE, 0xEF],
-//!         },
-//!     )),
-//! };
+//! # fn main() -> std::io::Result<()> {
+//!    let ports = list_flipper_ports()?;
 //!
-//! let response = cli.send_read_rpc_proto(ping)?;
-//! println!("{response:?}");
+//!    let port = &ports[0].port_name;
+//!
+//!    let mut cli = SerialRpcTransport::new(port.to_string())?;
+//!
+//!    let response = cli.send_and_receive(RpcRequest::SystemPlayAudiovisualAlert)?;
+//!
+//!    assert!(response.is_none());
+//!
+//! # Ok(())
+//! # }
 //! ```
 
-pub mod cli;
-pub mod error;
 pub mod proto;
-pub mod reader_utils;
+
+#[deny(missing_docs)]
+pub mod rpc;
+#[deny(missing_docs)]
+pub mod transport;
diff --git a/src/reader_utils.rs b/src/reader_utils.rs
deleted file mode 100644
index 96b2810..0000000
--- a/src/reader_utils.rs
+++ /dev/null
@@ -1,64 +0,0 @@
-use core::str;
-use std::io::{ErrorKind, Read};
-use std::time::{Duration, Instant};
-
-use crate::error::Result;
-
-/// Drain a stream until a str + padding chunk
-///
-/// Returns `Ok(())` if the byte is found, or an error if timed out or another I/O issue occurs.
-pub fn drain_until<R: Read>(reader: &mut R, until_str: &str, timeout: Duration) -> Result<()> {
-    assert!(!until_str.is_empty(), "until_str must not be empty");
-
-    const CHUNK_SIZE: usize = 256;
-
-    // INFO: In the worst case scenario, where the string starts @ the last byte in a chunk, it
-    // must fit within the second chunk, otherwise it will not be found.
-    assert!(until_str.len() <= CHUNK_SIZE + 1);
-
-    let until_bytes = until_str.as_bytes();
-
-    const BUF_LEN: usize = CHUNK_SIZE * 2;
-
-    let mut buf = [0u8; BUF_LEN]; // Two chunk juggle
-
-    let deadline = Instant::now() + timeout;
-
-    let finder = memchr::memmem::Finder::new(until_bytes);
-
-    let mut filled = 0;
-
-    loop {
-        if filled > CHUNK_SIZE {
-            buf.copy_within(CHUNK_SIZE.., 0);
-            filled -= CHUNK_SIZE;
-        }
-
-        let now = Instant::now();
-        if now >= deadline + timeout {
-            break;
-        }
-
-        match reader.read(&mut buf[filled..filled + CHUNK_SIZE.min(BUF_LEN - filled)]) {
-            Ok(0) => {
-                std::thread::sleep(Duration::from_millis(10));
-                continue;
-            }
-            Ok(n) => {
-                filled += n;
-
-                if finder.find(&buf).is_some() {
-                    return Ok(());
-                }
-            }
-            Err(ref e) if e.kind() == ErrorKind::TimedOut => continue,
-            Err(e) => return Err(e.into()),
-        }
-    }
-
-    Err(std::io::Error::new(
-        ErrorKind::TimedOut,
-        format!("Timeout searching for '{}'", until_str),
-    )
-    .into())
-}
diff --git a/src/rpc.rs b/src/rpc.rs
index 1558f0e..96d5f1b 100644
--- a/src/rpc.rs
+++ b/src/rpc.rs
@@ -1,82 +1,327 @@
-/// This file aims to make a better experience for end users by mapping proto::* classes into
-/// a user friendly Rpc::* enum and have better documentation
+//! This file aims to make a better experience for end users by mapping proto::* classes into
+//! a user friendly Rpc{Request, Response}::* enum and have better documentation
 
-/// Requests, these are made by the end user and will all normally recieve an RpcResponse
+use paste::paste;
+
+use crate::proto::StopSession;
+use crate::proto::app::{AppStateResponse, GetErrorResponse, LockStatusResponse};
+use crate::proto::desktop::{
+    IsLockedRequest, Status, StatusSubscribeRequest, StatusUnsubscribeRequest, UnlockRequest,
+};
+use crate::proto::gpio::{
+    GetOtgMode, GetOtgModeResponse, GetPinMode, GetPinModeResponse, ReadPin, ReadPinResponse,
+    SetInputPull, SetOtgMode, SetPinMode, WritePin,
+};
+use crate::proto::gui::{
+    ScreenFrame, SendInputEventRequest, StartScreenStreamRequest, StartVirtualDisplayRequest,
+    StopScreenStreamRequest, StopVirtualDisplayRequest,
+};
+use crate::proto::property::{GetRequest, GetResponse};
+use crate::proto::storage::{
+    InfoResponse, ListResponse, Md5sumResponse, ReadResponse, StatResponse, TimestampResponse,
+};
+use crate::proto::system::{
+    DeviceInfoRequest, DeviceInfoResponse, FactoryResetRequest, GetDateTimeResponse, PingRequest,
+    PowerInfoResponse, ProtobufVersionResponse, RebootRequest, SetDateTimeRequest, UpdateResponse,
+};
+use crate::proto::{
+    self, CommandStatus,
+    app::{
+        AppButtonPressReleaseRequest, AppButtonPressRequest, AppButtonReleaseRequest,
+        AppExitRequest, AppLoadFileRequest, DataExchangeRequest, GetErrorRequest,
+        LockStatusRequest, StartRequest,
+    },
+    storage::{
+        BackupCreateRequest, BackupRestoreRequest, DeleteRequest, InfoRequest, ListRequest,
+        Md5sumRequest, MkdirRequest, ReadRequest, RenameRequest, StatRequest, TarExtractRequest,
+        TimestampRequest, WriteRequest,
+    },
+    system::{DateTime, UpdateRequest, reboot_request::RebootMode},
+};
+
+// Generated by ChatGPT idk how to do macros
+macro_rules! define_into_impl {
+    ($enum_name:ident $variant:ident $typ:ty) => {
+        paste! {
+            impl $enum_name {
+               #[doc = stringify!(Reads the internal $typ data from a $enum_name::$variant)]
+               #[doc = r" Panics if the variant is not the same as the data type requested"]
+               pub fn [<into_ $variant:lower>](self) -> $typ {
+                    match self {
+                        $enum_name::$variant(x) => x,
+                        _ => panic!(concat!(
+                            "called `into_",
+                            stringify!($variant),
+                            "` on a non-",
+                            stringify!($variant),
+                            " value"
+                        )),
+                    }
+                }
+            }
+        }
+    };
+    ($enum_name:ident $variant:ident) => {};
+}
+
+macro_rules! define_into_enum {
+     (
+        $(#[$enum_meta:meta])*
+        $vis:vis enum $enum_name:ident {
+            $(
+                $(#[$variant_meta:meta])*
+                $variant:ident $( ( $typ:ty ) )?
+            ),* $(,)?
+        }
+    ) => {
+        $(#[$enum_meta])*
+        $vis enum $enum_name {
+            $(
+                $(#[$variant_meta])*
+                #[doc = stringify!($enum_name::$variant)]
+                $variant $( ( $typ ) )?,
+            )*
+        }
+
+        $(
+            define_into_impl!($enum_name $variant $( $typ)?);
+        )*
+    };
+}
+
+// bootleg proc-macros but i dont wanna make any
+define_into_enum! {
+    /// Wrapper around proto::Main tailored for requests. Can be turned into a proto::Main by
+    /// RcpRequest::into_rpc(self)
+#[derive(Debug)]
 pub enum RpcRequest {
-    StopSession(super::StopSession),
-    SystemPingRequest(super::super::system::PingRequest),
-    SystemRebootRequest(super::super::system::RebootRequest),
-    SystemDeviceInfoRequest(super::super::system::DeviceInfoRequest),
-    SystemFactoryResetRequest(super::super::system::FactoryResetRequest),
-    SystemGetDatetimeRequest(super::super::system::GetDateTimeRequest),
-    SystemSetDatetimeRequest(super::super::system::SetDateTimeRequest),
-    SystemPlayAudiovisualAlertRequest(super::super::system::PlayAudiovisualAlertRequest),
-    SystemProtobufVersionRequest(super::super::system::ProtobufVersionRequest),
-    SystemUpdateRequest(super::super::system::UpdateRequest),
-    SystemPowerInfoRequest(super::super::system::PowerInfoRequest),
-    StorageInfoRequest(super::super::storage::InfoRequest),
-    StorageTimestampRequest(super::super::storage::TimestampRequest),
-    StorageStatRequest(super::super::storage::StatRequest),
-    StorageListRequest(super::super::storage::ListRequest),
-    StorageReadRequest(super::super::storage::ReadRequest),
-    StorageWriteRequest(super::super::storage::WriteRequest),
-    StorageDeleteRequest(super::super::storage::DeleteRequest),
-    StorageMkdirRequest(super::super::storage::MkdirRequest),
-    StorageMd5sumRequest(super::super::storage::Md5sumRequest),
-    StorageRenameRequest(super::super::storage::RenameRequest),
-    StorageBackupCreateRequest(super::super::storage::BackupCreateRequest),
-    StorageBackupRestoreRequest(super::super::storage::BackupRestoreRequest),
-    StorageTarExtractRequest(super::super::storage::TarExtractRequest),
-    AppStartRequest(super::super::app::StartRequest),
-    AppLockStatusRequest(super::super::app::LockStatusRequest),
-    AppExitRequest(super::super::app::AppExitRequest),
-    AppLoadFileRequest(super::super::app::AppLoadFileRequest),
-    AppButtonPressRequest(super::super::app::AppButtonPressRequest),
-    AppButtonReleaseRequest(super::super::app::AppButtonReleaseRequest),
-    AppButtonPressReleaseRequest(super::super::app::AppButtonPressReleaseRequest),
-    AppGetErrorRequest(super::super::app::GetErrorRequest),
-    AppDataExchangeRequest(super::super::app::DataExchangeRequest),
-    GuiStartScreenStreamRequest(super::super::gui::StartScreenStreamRequest),
-    GuiStopScreenStreamRequest(super::super::gui::StopScreenStreamRequest),
-    GuiSendInputEventRequest(super::super::gui::SendInputEventRequest),
-    GuiStartVirtualDisplayRequest(super::super::gui::StartVirtualDisplayRequest),
-    GuiStopVirtualDisplayRequest(super::super::gui::StopVirtualDisplayRequest),
-    GpioSetPinMode(super::super::gpio::SetPinMode),
-    GpioSetInputPull(super::super::gpio::SetInputPull),
-    GpioGetPinMode(super::super::gpio::GetPinMode),
-    GpioReadPin(super::super::gpio::ReadPin),
-    GpioWritePin(super::super::gpio::WritePin),
-    GpioGetOtgMode(super::super::gpio::GetOtgMode),
-    GpioSetOtgMode(super::super::gpio::SetOtgMode),
-    PropertyGetRequest(super::super::property::GetRequest),
-    DesktopIsLockedRequest(super::super::desktop::IsLockedRequest),
-    DesktopUnlockRequest(super::super::desktop::UnlockRequest),
-    DesktopStatusSubscribeRequest(super::super::desktop::StatusSubscribeRequest),
-    DesktopStatusUnsubscribeRequest(super::super::desktop::StatusUnsubscribeRequest),
+    StopSession,
+    Ping(Vec<u8>),
+    Reboot(RebootMode),
+    SystemDeviceInfo,
+    SystemFactoryReset,
+    SystemGetDatetime,
+    SystemSetDatetime(DateTime),
+    SystemPlayAudiovisualAlert,
+    SystemProtobufVersion,
+    SystemUpdate(UpdateRequest),
+    SystemPowerInfo,
+    StorageInfo(InfoRequest),
+    StorageTimestamp(TimestampRequest),
+    StorageStat(StatRequest),
+    StorageList(ListRequest),
+    StorageRead(ReadRequest),
+    StorageWrite(WriteRequest),
+    StorageDelete(DeleteRequest),
+    StorageMkdir(MkdirRequest),
+    StorageMd5sumRequest(Md5sumRequest),
+    StorageRenameRequest(RenameRequest),
+    StorageBackupCreateRequest(BackupCreateRequest),
+    StorageBackupRestoreRequest(BackupRestoreRequest),
+    StorageTarExtractRequest(TarExtractRequest),
+    AppStartRequest(StartRequest),
+    AppLockStatusRequest(LockStatusRequest),
+    AppExitRequest(AppExitRequest),
+    AppLoadFileRequest(AppLoadFileRequest),
+    AppButtonPressRequest(AppButtonPressRequest),
+    AppButtonReleaseRequest(AppButtonReleaseRequest),
+    AppButtonPressReleaseRequest(AppButtonPressReleaseRequest),
+    AppGetErrorRequest(GetErrorRequest),
+    AppDataExchangeRequest(DataExchangeRequest),
+    GuiStartScreenStreamRequest(StartScreenStreamRequest),
+    GuiStopScreenStreamRequest(StopScreenStreamRequest),
+    GuiSendInputEventRequest(SendInputEventRequest),
+    GuiStartVirtualDisplayRequest(StartVirtualDisplayRequest),
+    GuiStopVirtualDisplayRequest(StopVirtualDisplayRequest),
+    GpioSetPinMode(SetPinMode),
+    GpioSetInputPull(SetInputPull),
+    GpioGetPinMode(GetPinMode),
+    GpioReadPin(ReadPin),
+    GpioWritePin(WritePin),
+    GpioGetOtgMode(GetOtgMode),
+    GpioSetOtgMode(SetOtgMode),
+    PropertyGetRequest(GetRequest),
+    DesktopIsLockedRequest(IsLockedRequest),
+    DesktopUnlockRequest(UnlockRequest),
+    DesktopStatusSubscribeRequest(StatusSubscribeRequest),
+    DesktopStatusUnsubscribeRequest(StatusUnsubscribeRequest),
+}
 }
 
-/// Reponse from flipper
+define_into_enum! {
+    /// Wrapper around proto::Main tailored for responses. Can be made from a proto::Main by
+    /// Into/From
+#[derive(Debug)]
 pub enum RpcResponse {
     Empty,
-    SystemPingResponse(super::super::system::PingResponse),
-    SystemDeviceInfoResponse(super::super::system::DeviceInfoResponse),
-    SystemGetDatetimeResponse(super::super::system::GetDateTimeResponse),
-    SystemProtobufVersionResponse(super::super::system::ProtobufVersionResponse),
-    SystemUpdateResponse(super::super::system::UpdateResponse),
-    SystemPowerInfoResponse(super::super::system::PowerInfoResponse),
-    StorageInfoResponse(super::super::storage::InfoResponse),
-    StorageTimestampResponse(super::super::storage::TimestampResponse),
-    StorageStatResponse(super::super::storage::StatResponse),
-    StorageListResponse(super::super::storage::ListResponse),
-    StorageReadResponse(super::super::storage::ReadResponse),
-    StorageMd5sumResponse(super::super::storage::Md5sumResponse),
-    AppLockStatusResponse(super::super::app::LockStatusResponse),
-    AppGetErrorResponse(super::super::app::GetErrorResponse),
-    GuiScreenFrame(super::super::gui::ScreenFrame),
-    GpioGetPinModeResponse(super::super::gpio::GetPinModeResponse),
-    GpioReadPinResponse(super::super::gpio::ReadPinResponse),
-    GpioGetOtgModeResponse(super::super::gpio::GetOtgModeResponse),
-    AppStateResponse(super::super::app::AppStateResponse),
-    PropertyGetResponse(super::super::property::GetResponse),
-    DesktopStatus(super::super::desktop::Status),
+    Ping(Vec<u8>),
+    SystemDeviceInfoResponse(DeviceInfoResponse),
+    SystemGetDatetimeResponse(GetDateTimeResponse),
+    SystemProtobufVersionResponse(ProtobufVersionResponse),
+    SystemUpdateResponse(UpdateResponse),
+    SystemPowerInfoResponse(PowerInfoResponse),
+    StorageInfoResponse(InfoResponse),
+    StorageTimestampResponse(TimestampResponse),
+    StorageStatResponse(StatResponse),
+    StorageListResponse(ListResponse),
+    StorageReadResponse(ReadResponse),
+    StorageMd5sumResponse(Md5sumResponse),
+    AppLockStatusResponse(LockStatusResponse),
+    AppGetErrorResponse(GetErrorResponse),
+    GuiScreenFrame(ScreenFrame),
+    GpioGetPinModeResponse(GetPinModeResponse),
+    GpioReadPinResponse(ReadPinResponse),
+    GpioGetOtgModeResponse(GetOtgModeResponse),
+    AppStateResponse(AppStateResponse),
+    PropertyGetResponse(GetResponse),
+    DesktopStatus(Status),
+}
+}
+
+impl RpcRequest {
+    /// Creates a proto::Main from an RpcRequest
+    ///
+    /// Useful for actually sending the requests, as this is what the API expects. Does not error.
+    pub fn into_rpc(self, command_id: u32, has_next: bool) -> proto::Main {
+        use proto::main::Content;
+
+        proto::Main {
+            command_id,
+            command_status: CommandStatus::Ok.into(),
+            has_next,
+
+            // TODO: Implement user-friendly methods for all of these
+            content: Some(match self {
+                RpcRequest::StopSession => Content::StopSession(StopSession {}),
+                RpcRequest::Ping(data) => Content::SystemPingRequest(PingRequest { data }),
+                RpcRequest::Reboot(reboot_mode) => Content::SystemRebootRequest(RebootRequest {
+                    mode: reboot_mode.into(),
+                }),
+
+                RpcRequest::SystemDeviceInfo => {
+                    Content::SystemDeviceInfoRequest(DeviceInfoRequest {})
+                }
+                RpcRequest::SystemFactoryReset => {
+                    Content::SystemFactoryResetRequest(FactoryResetRequest {})
+                }
+                RpcRequest::SystemGetDatetime => {
+                    Content::SystemGetDatetimeRequest(crate::proto::system::GetDateTimeRequest {})
+                } // ← import GetDateTimeRequest
+                RpcRequest::SystemSetDatetime(date_time) => {
+                    Content::SystemSetDatetimeRequest(SetDateTimeRequest {
+                        datetime: Some(date_time),
+                    })
+                }
+                RpcRequest::SystemPlayAudiovisualAlert => {
+                    Content::SystemPlayAudiovisualAlertRequest(
+                        crate::proto::system::PlayAudiovisualAlertRequest {},
+                    )
+                }
+                RpcRequest::SystemProtobufVersion => Content::SystemProtobufVersionRequest(
+                    crate::proto::system::ProtobufVersionRequest {},
+                ),
+                RpcRequest::SystemUpdate(update_req) => {
+                    Content::SystemUpdateRequest(UpdateRequest { ..update_req })
+                }
+                RpcRequest::SystemPowerInfo => {
+                    Content::SystemPowerInfoRequest(crate::proto::system::PowerInfoRequest {})
+                }
+                RpcRequest::StorageInfo(req) => Content::StorageInfoRequest(req),
+                RpcRequest::StorageTimestamp(req) => Content::StorageTimestampRequest(req),
+                RpcRequest::StorageStat(req) => Content::StorageStatRequest(req),
+                RpcRequest::StorageList(req) => Content::StorageListRequest(req),
+                RpcRequest::StorageRead(req) => Content::StorageReadRequest(req),
+                RpcRequest::StorageWrite(req) => Content::StorageWriteRequest(req),
+                RpcRequest::StorageDelete(req) => Content::StorageDeleteRequest(req),
+                RpcRequest::StorageMkdir(req) => Content::StorageMkdirRequest(req),
+                RpcRequest::StorageMd5sumRequest(req) => Content::StorageMd5sumRequest(req),
+                RpcRequest::StorageRenameRequest(req) => Content::StorageRenameRequest(req),
+                RpcRequest::StorageBackupCreateRequest(req) => {
+                    Content::StorageBackupCreateRequest(req)
+                }
+                RpcRequest::StorageBackupRestoreRequest(req) => {
+                    Content::StorageBackupRestoreRequest(req)
+                }
+                RpcRequest::StorageTarExtractRequest(req) => Content::StorageTarExtractRequest(req),
+
+                RpcRequest::AppStartRequest(req) => Content::AppStartRequest(req),
+                RpcRequest::AppLockStatusRequest(req) => Content::AppLockStatusRequest(req),
+                RpcRequest::AppExitRequest(req) => Content::AppExitRequest(req),
+                RpcRequest::AppLoadFileRequest(req) => Content::AppLoadFileRequest(req),
+                RpcRequest::AppButtonPressRequest(req) => Content::AppButtonPressRequest(req),
+                RpcRequest::AppButtonReleaseRequest(req) => Content::AppButtonReleaseRequest(req),
+                RpcRequest::AppButtonPressReleaseRequest(req) => {
+                    Content::AppButtonPressReleaseRequest(req)
+                }
+                RpcRequest::AppDataExchangeRequest(req) => Content::AppDataExchangeRequest(req),
+                RpcRequest::AppGetErrorRequest(req) => Content::AppGetErrorRequest(req),
+
+                RpcRequest::GuiStartScreenStreamRequest(req) => {
+                    Content::GuiStartScreenStreamRequest(req)
+                }
+                RpcRequest::GuiStopScreenStreamRequest(req) => {
+                    Content::GuiStopScreenStreamRequest(req)
+                }
+                RpcRequest::GuiSendInputEventRequest(req) => Content::GuiSendInputEventRequest(req),
+                RpcRequest::GuiStartVirtualDisplayRequest(req) => {
+                    Content::GuiStartVirtualDisplayRequest(req)
+                }
+                RpcRequest::GuiStopVirtualDisplayRequest(req) => {
+                    Content::GuiStopVirtualDisplayRequest(req)
+                }
+
+                RpcRequest::GpioSetPinMode(req) => Content::GpioSetPinMode(req),
+                RpcRequest::GpioSetInputPull(req) => Content::GpioSetInputPull(req),
+                RpcRequest::GpioGetPinMode(req) => Content::GpioGetPinMode(req),
+                RpcRequest::GpioReadPin(req) => Content::GpioReadPin(req),
+                RpcRequest::GpioWritePin(req) => Content::GpioWritePin(req),
+                RpcRequest::GpioGetOtgMode(req) => Content::GpioGetOtgMode(req),
+                RpcRequest::GpioSetOtgMode(req) => Content::GpioSetOtgMode(req),
+
+                RpcRequest::PropertyGetRequest(req) => Content::PropertyGetRequest(req),
+                RpcRequest::DesktopIsLockedRequest(req) => Content::DesktopIsLockedRequest(req),
+                RpcRequest::DesktopUnlockRequest(req) => Content::DesktopUnlockRequest(req),
+                RpcRequest::DesktopStatusSubscribeRequest(req) => {
+                    Content::DesktopStatusSubscribeRequest(req)
+                }
+                RpcRequest::DesktopStatusUnsubscribeRequest(req) => {
+                    Content::DesktopStatusUnsubscribeRequest(req)
+                }
+            }),
+        }
+    }
+}
+
+impl From<proto::Main> for RpcResponse {
+    fn from(val: proto::Main) -> Self {
+        use proto::main::Content::*;
+        let content = val.content.unwrap();
+
+        match content {
+            Empty(_) => RpcResponse::Empty,
+            SystemPingResponse(r) => RpcResponse::Ping(r.data),
+            SystemDeviceInfoResponse(r) => RpcResponse::SystemDeviceInfoResponse(r),
+            SystemGetDatetimeResponse(r) => RpcResponse::SystemGetDatetimeResponse(r),
+            SystemProtobufVersionResponse(r) => RpcResponse::SystemProtobufVersionResponse(r),
+            SystemUpdateResponse(r) => RpcResponse::SystemUpdateResponse(r),
+            SystemPowerInfoResponse(r) => RpcResponse::SystemPowerInfoResponse(r),
+            StorageInfoResponse(r) => RpcResponse::StorageInfoResponse(r),
+            StorageTimestampResponse(r) => RpcResponse::StorageTimestampResponse(r),
+            StorageStatResponse(r) => RpcResponse::StorageStatResponse(r),
+            StorageListResponse(r) => RpcResponse::StorageListResponse(r),
+            StorageReadResponse(r) => RpcResponse::StorageReadResponse(r),
+            StorageMd5sumResponse(r) => RpcResponse::StorageMd5sumResponse(r),
+            AppLockStatusResponse(r) => RpcResponse::AppLockStatusResponse(r),
+            AppGetErrorResponse(r) => RpcResponse::AppGetErrorResponse(r),
+            GuiScreenFrame(r) => RpcResponse::GuiScreenFrame(r),
+            GpioGetPinModeResponse(r) => RpcResponse::GpioGetPinModeResponse(r),
+            GpioReadPinResponse(r) => RpcResponse::GpioReadPinResponse(r),
+            GpioGetOtgModeResponse(r) => RpcResponse::GpioGetOtgModeResponse(r),
+            AppStateResponse(r) => RpcResponse::AppStateResponse(r),
+            PropertyGetResponse(r) => RpcResponse::PropertyGetResponse(r),
+            DesktopStatus(r) => RpcResponse::DesktopStatus(r),
+
+            _ => panic!("Cannot convert {:?} into RpcResponse", content),
+        }
+    }
 }
