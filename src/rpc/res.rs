//! Response type. Maps all Content's ending with "Response"

use crate::proto::app::{AppStateResponse, GetErrorResponse, LockStatusResponse};
use crate::proto::desktop::Status;
use crate::proto::gpio::{GetOtgModeResponse, GetPinModeResponse, ReadPinResponse};
use crate::proto::gui::ScreenFrame;
use crate::proto::main::Content;
use crate::proto::property::GetResponse;
use crate::proto::storage::file::FileType;
use crate::proto::storage::{File, InfoResponse, Md5sumResponse, StatResponse, TimestampResponse};
use crate::proto::system::{
    DeviceInfoResponse, PowerInfoResponse, ProtobufVersionResponse, UpdateResponse,
};
use crate::proto::{self, system::DateTime};

// Generated by ChatGPT idk how to do macros
/*macro_rules! define_into_impl {
    ($enum_name:ident $variant:ident $typ:ty) => {
        paste! {
            impl $enum_name {
               #[doc = stringify!(Reads the internal $typ data from a $enum_name::$variant)]
               #[doc = r" Panics if the variant is not the same as the data type requested"]
               pub fn [<into_ $variant:lower>](self) -> $typ {
                    match self {
                        $enum_name::$variant(x) => x,
                        _ => panic!(concat!(
                            "called `into_",
                            stringify!($variant),
                            "` on a non-",
                            stringify!($variant),
                            " value"
                        )),
                    }
                }
            }
        }
    };
    ($enum_name:ident $variant:ident) => {};
}*/
macro_rules! define_into_impl {
    ($enum_name:ident $variant:ident $typ:ty) => {
        impl std::convert::TryInto<$typ> for $enum_name {
            type Error = crate::error::Error;

            fn try_into(self) -> Result<$typ, Self::Error> {
                match self {
                    $enum_name::$variant(x) => Ok(x),
                    x => Err(std::io::Error::new(
                        std::io::ErrorKind::InvalidInput,
                        format!(
                            "Cannot convert {x:?} into a  {}",
                            stringify!($enum_name::$variant)
                        ),
                    )
                    .into()),
                }
            }
        }
    };
    ($enum_name:ident $variant:ident) => {};
}

macro_rules! define_into_enum {
     (
        $(#[$enum_meta:meta])*
        $vis:vis enum $enum_name:ident {
            $(
                $(#[$variant_meta:meta])*
                $variant:ident $( ( $typ:ty ) )?
            ),* $(,)?
        }
    ) => {
        $(#[$enum_meta])*
        $vis enum $enum_name {
            $(
                $(#[$variant_meta])*
                #[doc = stringify!($enum_name::$variant)]
                $variant $( ( $typ ) )?,
            )*
        }

        $(
            define_into_impl!($enum_name $variant $( $typ)?);
        )*
    };
}

// bootleg proc-macros but i dont wanna make any
define_into_enum! {
    /// Wrapper around proto::Main tailored for responses. Can be made from a proto::Main by
    /// Into/From
#[derive(Debug, PartialEq)]
pub enum Response {
    Empty,
    Ping(Vec<u8>),
    SystemDeviceInfo(DeviceInfoResponse),
    SystemGetDatetime(Option<DateTime>),
    SystemProtobufVersion(ProtobufVersionResponse),
    SystemUpdate(UpdateResponse),
    SystemPowerInfo(PowerInfoResponse),
    StorageInfo(InfoResponse),
    StorageTimestamp(TimestampResponse),
    StorageStat(StatResponse),
    StorageList(Vec<File>),
    StorageRead(Option<ReadFile>),
    StorageMd5sum(Md5sumResponse),
    AppLockStatus(LockStatusResponse),
    AppGetError(GetErrorResponse),
    GuiScreenFrame(ScreenFrame),
    GpioGetPinMode(GetPinModeResponse),
    GpioReadPin(ReadPinResponse),
    GpioGetOtgMode(GetOtgModeResponse),
    AppState(AppStateResponse),
    PropertyGet(GetResponse),
    DesktopStatus(Status),
}
}

/// File read using fs_read / Request::StorageRead
#[derive(Debug, PartialEq)]
pub enum ReadFile {
    /// Directory
    Dir,
    /// File + Data and then MD5 Hash
    File(Vec<u8>, String),
}

impl From<proto::Main> for Response {
    fn from(val: proto::Main) -> Self {
        use Response::*;
        let content = val.content;

        match content {
            None | Some(Content::Empty(_)) => Empty,
            Some(x) => match x {
                Content::SystemPingResponse(r) => Ping(r.data),
                Content::SystemDeviceInfoResponse(r) => SystemDeviceInfo(r),
                Content::SystemGetDatetimeResponse(r) => SystemGetDatetime(r.datetime),
                Content::SystemProtobufVersionResponse(r) => SystemProtobufVersion(r),
                Content::SystemUpdateResponse(r) => SystemUpdate(r),
                Content::SystemPowerInfoResponse(r) => SystemPowerInfo(r),
                Content::StorageInfoResponse(r) => StorageInfo(r),
                Content::StorageTimestampResponse(r) => StorageTimestamp(r),
                Content::StorageStatResponse(r) => StorageStat(r),
                Content::StorageListResponse(r) => StorageList(r.file),
                Content::StorageReadResponse(r) => {
                    // Will not be invalid data unless the flipper returns invalid data
                    StorageRead(r.file.map(|x| match FileType::try_from(x.r#type).unwrap() {
                        FileType::File => ReadFile::File(x.data, x.md5sum),
                        FileType::Dir => ReadFile::Dir,
                    }))
                }
                Content::StorageMd5sumResponse(r) => StorageMd5sum(r),
                Content::AppLockStatusResponse(r) => AppLockStatus(r),
                Content::AppGetErrorResponse(r) => AppGetError(r),
                Content::GuiScreenFrame(r) => GuiScreenFrame(r),
                Content::GpioGetPinModeResponse(r) => GpioGetPinMode(r),
                Content::GpioReadPinResponse(r) => GpioReadPin(r),
                Content::GpioGetOtgModeResponse(r) => GpioGetOtgMode(r),
                Content::AppStateResponse(r) => AppState(r),
                Content::PropertyGetResponse(r) => PropertyGet(r),
                Content::DesktopStatus(r) => DesktopStatus(r),

                _ => panic!("Cannot convert {:?} into RpcResponse", x),
            },
        }
    }
}
